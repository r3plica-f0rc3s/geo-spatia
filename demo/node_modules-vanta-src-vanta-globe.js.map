{"version":3,"sources":["./node_modules/vanta/src/vanta.globe.js","./node_modules/vanta/src/helpers.js","./node_modules/vanta/src/_base.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAA2C;AACG;;AAE9C;AACA;;AAEA,qBAAqB,gDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,kCAAkC;AAClC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,UAAU;;AAEnB;AACA;AACA;;AAEA,mBAAmB,iEAAa;AAChC,gBAAgB,iEAAa;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,MAAM;AACzB,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA,uBAAuB,qBAAqB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,mDAAmD,6BAA6B;AAChF;AACA,mBAAmB,QAAQ;AAC3B,iBAAiB,sDAAE;AACnB,sBAAsB,sDAAE;AACxB;AACA,gBAAgB,sDAAE;AAClB;AACA,oBAAoB,sDAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACe,6GAAK,0B;;;;;;;;;;;;ACrYpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAA6C;;AAE7C;;AAEO;AACP;AACA,gCAAgC;AAChC;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACO;;AAEA;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;;AAEA;AACP;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA,8BAA8B,EAAE,UAAU,EAAE,UAAU,EAAE;AACxD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEO;AACP;AACA,C;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAA8D;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0DAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA,IAAI,0DAAM;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,qDAAC;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,IAAI,0DAAM;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC,IAAI,0DAAM;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,0DAAM;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,+DAAW;AACnB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,8E","file":"node_modules-vanta-src-vanta-globe.js","sourcesContent":["import VantaBase, {VANTA} from './_base.js'\nimport {rn, getBrightness} from './helpers.js'\n\nconst win = typeof window == 'object'\nlet THREE = win && window.THREE\n\nclass Effect extends VantaBase {\n  static initClass() {\n    this.prototype.defaultOptions = {\n      color: 0xff3f81,\n      color2: 0xffffff,\n      size: 1,\n      backgroundColor: 0x23153c,\n      points: 10,\n      maxDistance: 20,\n      spacing: 15,\n      showDots: true\n    }\n  }\n\n  constructor(userOptions) {\n    THREE = userOptions.THREE || THREE\n    super(userOptions)\n  }\n\n  // onInit() {\n  //   this.geometry = new THREE.BoxGeometry( 10, 10, 10 );\n  //   this.material = new THREE.MeshLambertMaterial({\n  //     color: this.options.color,\n  //     emissive: this.options.color,\n  //     emissiveIntensity: 0.75\n  //   });\n  //   this.cube = new THREE.Mesh( this.geometry, this.material );\n  //   this.scene.add(this.cube);\n\n  //   const c = this.camera = new THREE.PerspectiveCamera( 75, this.width/this.height, 0.1, 1000 );\n  //   c.position.z = 30;\n  //   c.lookAt(0,0,0);\n  //   this.scene.add(c);\n\n  //   const light = new THREE.HemisphereLight( 0xffffff, this.options.backgroundColor , 1 );\n  //   this.scene.add(light);\n  // }\n\n  // onUpdate() {\n  //   this.cube.rotation.x += 0.01;\n  //   this.cube.rotation.y += 0.01;\n  // }\n\n  genPoint(x, y, z) {\n    let sphere\n    if (!this.points) { this.points = [] }\n\n    if (this.options.showDots) {\n      const geometry = new THREE.SphereGeometry( 0.25, 12, 12 ) // radius, width, height\n      const material = new THREE.MeshLambertMaterial({\n        color: this.options.color})\n      sphere = new THREE.Mesh( geometry, material )\n    } else {\n      sphere = new THREE.Object3D()\n    }\n    this.cont.add( sphere )\n    sphere.ox = x\n    sphere.oy = y\n    sphere.oz = z\n    sphere.position.set(x,y,z)\n    sphere.r = 0 // rotation rate\n    return this.points.push(sphere)\n  }\n\n  onInit() {\n    this.cont = new THREE.Group()\n    this.cont.position.set(-50,-20,0)\n    this.scene.add(this.cont)\n\n    let n = this.options.points\n    let { spacing } = this.options\n\n    const numPoints = n * n * 2\n    this.linePositions = new Float32Array( numPoints * numPoints * 3 )\n    this.lineColors = new Float32Array( numPoints * numPoints * 3 )\n\n    const colorB = getBrightness(new THREE.Color(this.options.color))\n    const bgB = getBrightness(new THREE.Color(this.options.backgroundColor))\n    this.blending =  colorB > bgB ? 'additive' : 'subtractive'\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position',\n      new THREE.BufferAttribute(this.linePositions, 3).setUsage(THREE.DynamicDrawUsage))\n    geometry.setAttribute('color',\n      new THREE.BufferAttribute(this.lineColors, 3).setUsage(THREE.DynamicDrawUsage))\n    geometry.computeBoundingSphere()\n    geometry.setDrawRange( 0, 0 )\n    const material = new THREE.LineBasicMaterial({\n      vertexColors: THREE.VertexColors,\n      blending: this.blending === 'additive' ? THREE.AdditiveBlending : null,\n      // blending: THREE.SubtractiveBlending\n      transparent: true\n    });\n      // blending: THREE.CustomBlending\n      // blendEquation: THREE.SubtractEquation\n      // blendSrc: THREE.SrcAlphaFactor\n      // blendDst: THREE.OneMinusSrcAlphaFactor\n\n    this.linesMesh = new THREE.LineSegments( geometry, material )\n    this.cont.add( this.linesMesh )\n\n    for (let i = 0; i<=n; i++) {\n      for (let j = 0; j<=n; j++) {\n        const y = 0\n        const x = ((i - (n/2)) * spacing)\n        let z = ((j - (n/2)) * spacing)\n        // if (i % 2) { z += spacing * 0.5 } // offset\n\n        // nexusX = Math.round(x / 20) * 20\n        // nexusZ = Math.round(z / 20) * 20\n        // x += (nexusX - x) * 0.01\n        // z += (nexusZ - z) * 0.01\n        this.genPoint(x, y, z)\n        // this.genPoint(x + ri(-5,5), y, z + ri(-5,5))\n      }\n    }\n\n    //  # radius\n    //   width, # width\n    //   rn(0,1000), # startAng\n    //   rn(1,6), # ang\n    //   rn(0, 50/(radius+1) + 5) + 5/width/(radius+0.5), # y\n    //   Math.max(-rn(0.5,2), rn(1, 50-radius/2) - radius/2) * 0.25 # speed\n    // )\n\n    // PerspectiveCamera( fov, aspect, near, far )\n    this.camera = new THREE.PerspectiveCamera(\n      20,\n      this.width / this.height,\n      0.01, 10000);\n    this.camera.position.set(50, 100, 150)\n    this.scene.add( this.camera )\n\n    // ambience = new THREE.AmbientLight(0xffffff, 0.01)\n    // @scene.add(ambience)\n\n    // @pointLight = new THREE.PointLight(0xFFFFFF, 0.01)\n    // @pointLight.position.set(0, 150, 200)\n    // @scene.add( @pointLight )\n\n    const ambience = new THREE.AmbientLight(0xffffff, 0.75)\n    this.scene.add(ambience)\n\n    this.spot = new THREE.SpotLight(0xFFFFFF, 1)\n    this.spot.position.set(0, 200, 0)\n    this.spot.distance = 400\n    this.spot.target = this.cont\n    this.scene.add(this.spot)\n\n\n    // LINES BALL\n    this.cont2 = new THREE.Group()\n    this.cont2.position.set(0, 15, 0)\n    this.scene.add(this.cont2)\n\n    const material2 = new THREE.LineBasicMaterial({ color: this.options.color2 })\n    const linesGeo = new THREE.Geometry()\n    for (let i = 0; i < 80; i ++) {\n      const f1 = rn(18,24)\n      const f2 = f1 + rn(1,6)\n      // https://math.stackexchange.com/questions/1585975/how-to-generate-random-points-on-a-sphere\n      const z = rn(-1,1)\n      const r = Math.sqrt(1 - z*z)\n      const theta = rn(0, Math.PI * 2)\n      const y = Math.sin(theta) * r\n      const x = Math.cos(theta) * r\n      linesGeo.vertices.push(new THREE.Vector3( x*f1, y*f1, z*f1) )\n      linesGeo.vertices.push(new THREE.Vector3( x*f2, y*f2, z*f2) )\n    }\n    this.linesMesh2 = new THREE.LineSegments( linesGeo, material2 )\n    this.linesMesh2.position.set(0, 0, 0)\n    this.cont2.add(this.linesMesh2)\n\n    // Poles\n    const material3 = new THREE.LineBasicMaterial( {\n      color: this.options.color2,\n      linewidth: 2,\n    } )\n    const linesGeo3 = new THREE.Geometry()\n    linesGeo3.vertices.push(new THREE.Vector3( 0, 30, 0))\n    linesGeo3.vertices.push(new THREE.Vector3( 0, -30, 0))\n    const num = 4\n    for (let i = 0; i < num; i ++) {\n      let x = 0.15 * Math.cos(i/num*Math.PI*2),\n          z = 0.15 * Math.sin(i/num*Math.PI*2)\n      let heights = [17.9,12,8,5,3,2,1.5,1.1,0.8,0.6,0.45,0.3,0.2,0.1,0.05,0.03,0.02,0.01]\n      for (let j = 0; j<heights.length; j++) {\n        let h = heights[j], r = 6*(j+1)\n        linesGeo3.vertices.push(new THREE.Vector3(x*r, h, z*r))\n        linesGeo3.vertices.push(new THREE.Vector3(x*r, -h, z*r))\n      }\n    }\n    this.linesMesh3 = new THREE.LineSegments( linesGeo3, material3 )\n    this.linesMesh3.position.set(0, 0, 0)\n    this.cont2.add(this.linesMesh3)\n\n\n    // GLOBE\n    // https://stackoverflow.com/questions/20153705/three-js-wireframe-material-all-polygons-vs-just-edges\n    const wireMat = new THREE.LineBasicMaterial({ color: this.options.color })\n    const sphereGeom = new THREE.SphereGeometry( 18*this.options.size, 18, 14 )\n    const edges = new THREE.EdgesGeometry(sphereGeom)\n    this.sphere = new THREE.LineSegments( edges, wireMat )\n    this.sphere.position.set(0, 0, 0)\n    this.cont2.add(this.sphere)\n\n    this.cont2.rotation.x = -0.25\n\n\n  }\n\n  onUpdate() {\n    let diff\n    if (this.helper != null) {\n      this.helper.update()\n    }\n    if (this.controls != null) {\n      this.controls.update()\n    }\n\n    const c = this.camera\n    if (Math.abs(c.tx - c.position.x) > 0.01) {\n      diff = c.tx - c.position.x\n      c.position.x += diff * 0.02\n    }\n    if (Math.abs(c.ty - c.position.y) > 0.01) {\n      diff = c.ty - c.position.y\n      c.position.y += diff * 0.02\n    }\n    if (win && window.innerWidth < 480) {\n      c.lookAt( new THREE.Vector3( -10, 0, 0 ) )\n    } else if (win && window.innerWidth < 720) {\n      c.lookAt( new THREE.Vector3( -20, 0, 0 ) )\n    } else c.lookAt( new THREE.Vector3( -40, 0, 0 ) )\n    // c.near = 0.01\n    // c.updateProjectionMatrix()\n\n    let vertexpos = 0\n    let colorpos = 0\n    let numConnected = 0\n\n    const bgColor = new THREE.Color(this.options.backgroundColor)\n    const color = new THREE.Color(this.options.color)\n    const color2 = new THREE.Color(this.options.color2)\n    const diffColor = color.clone().sub(bgColor)\n\n    if (this.rayCaster) {\n      this.rayCaster.setFromCamera(new THREE.Vector2(this.rcMouseX,this.rcMouseY), this.camera)\n    }\n\n    if (this.linesMesh2) {\n      this.linesMesh2.rotation.z += 0.002\n      this.linesMesh2.rotation.x += 0.0008\n      this.linesMesh2.rotation.y += 0.0005\n    }\n    if (this.sphere) {\n      this.sphere.rotation.y += 0.002\n      this.linesMesh3.rotation.y -= 0.004\n    }\n\n    // # TEMPORARY RAY DRAWING\n    // pointA = @camera.position\n    // direction = @rayCaster.ray.direction\n    // direction.normalize()\n    // distance = 1000000 # at what distance to determine pointB\n    // pointB = new THREE.Vector3()\n    // pointB.addVectors( pointA, direction.multiplyScalar( distance ) )\n    // geometry = new THREE.Geometry()\n    // geometry.vertices.push( pointA )\n    // geometry.vertices.push( pointB )\n    // material = new THREE.LineBasicMaterial( { color : 0xffffff } )\n    // line = new THREE.Line( geometry, material )\n    // @scene.add( line )\n\n    for (let i = 0; i < this.points.length; i++) {\n      let dist, distToMouse\n      const p = this.points[i]\n      // p.position.y += Math.sin(@t * 0.005 - 0.02 * p.ox + 0.015 * p.oz) * 0.02\n\n      if (this.rayCaster) {\n        distToMouse = this.rayCaster.ray.distanceToPoint(p.position)\n      } else {\n        distToMouse = 1000\n      }\n      const distClamp = distToMouse.clamp(5,15)\n      p.scale.z = ((15 - distClamp) * 0.25).clamp(1, 100)\n      p.scale.x = p.scale.y = p.scale.z\n\n      // if (p.r !== 0) {\n      //   let ang = Math.atan2( p.position.z, p.position.x )\n      //   dist = Math.sqrt( (p.position.z * p.position.z) + (p.position.x * p.position.x) )\n      //   // ang += 0.0005 * p.r\n      //   p.position.x = dist * Math.cos(ang)\n      //   p.position.z = dist * Math.sin(ang)\n      // }\n\n      p.position.y = 2 * Math.sin(\n        p.position.x/10 + this.t*0.01\n        + p.position.z/10 * 0.5\n      )\n\n        // p.position.x += Math.sin(@t * 0.01 + p.position.y) * 0.02\n        // p.position.z += Math.sin(@t * 0.01 - p.position.y) * 0.02\n\n      for (let j = i; j < this.points.length; j++) {\n        const p2 = this.points[j]\n        const dx = p.position.x - p2.position.x\n        const dy = p.position.y - p2.position.y\n        const dz = p.position.z - p2.position.z\n        dist = Math.sqrt( (dx * dx) + (dy * dy) + (dz * dz) )\n        if (dist < this.options.maxDistance) {\n          let lineColor\n          let alpha = (( 1.0 - (dist / this.options.maxDistance) ) * 2)\n          alpha = alpha.clamp(0, 1)\n          if (this.blending === 'additive') {\n            lineColor = new THREE.Color(0x000000).lerp(diffColor, alpha)\n          } else {\n            lineColor = bgColor.clone().lerp(color, alpha)\n          }\n          // if @blending == 'subtractive'\n          //   lineColor = new THREE.Color(0x000000).lerp(diffColor, alpha)\n\n          this.linePositions[ vertexpos++ ] = p.position.x\n          this.linePositions[ vertexpos++ ] = p.position.y\n          this.linePositions[ vertexpos++ ] = p.position.z\n          this.linePositions[ vertexpos++ ] = p2.position.x\n          this.linePositions[ vertexpos++ ] = p2.position.y\n          this.linePositions[ vertexpos++ ] = p2.position.z\n\n          this.lineColors[ colorpos++ ] = lineColor.r\n          this.lineColors[ colorpos++ ] = lineColor.g\n          this.lineColors[ colorpos++ ] = lineColor.b\n          this.lineColors[ colorpos++ ] = lineColor.r\n          this.lineColors[ colorpos++ ] = lineColor.g\n          this.lineColors[ colorpos++ ] = lineColor.b\n\n          numConnected++\n        }\n      }\n    }\n    this.linesMesh.geometry.setDrawRange( 0, numConnected * 2 )\n    this.linesMesh.geometry.attributes.position.needsUpdate = true\n    this.linesMesh.geometry.attributes.color.needsUpdate = true\n    // @pointCloud.geometry.attributes.position.needsUpdate = true\n\n    // Update other colors\n    this.sphere.material.color.set(color)\n    this.linesMesh2.material.color.set(color2)\n    this.linesMesh3.material.color.set(color2)\n\n    return this.t * 0.001\n  }\n    // @cont.rotation.x += Math.sin(t) * 0.0001\n    // @cont.rotation.z += Math.cos(t) * 0.00007\n\n\n  onMouseMove(x,y) {\n    const c = this.camera\n    if (!c.oy) {\n      c.oy = c.position.y\n      c.ox = c.position.x\n      c.oz = c.position.z\n    }\n    const ang = Math.atan2(c.oz, c.ox)\n    const dist = Math.sqrt((c.oz*c.oz) + (c.ox*c.ox))\n    const tAng = ang + ((x-0.5) * 1.5 * (this.options.mouseCoeffX || 1))\n    c.tz = dist * Math.sin(tAng)\n    c.tx = dist * Math.cos(tAng)\n    c.ty = c.oy + ((y-0.5) * 80 * (this.options.mouseCoeffY || 1))\n\n    if (!this.rayCaster) {\n      // this.rayCaster = new THREE.Raycaster()\n    }\n    this.rcMouseX = (x * 2) - 1\n    this.rcMouseY = (- x * 2) + 1\n  }\n\n  onRestart() {\n    this.scene.remove( this.linesMesh )\n    this.points = []\n  }\n}\nEffect.initClass()\nexport default VANTA.register('GLOBE', Effect)","Number.prototype.clamp = function(min, max) { return Math.min(Math.max(this, min), max) }\n\n// # module.exports = helpers\n\nexport function extend(a, b) {\n  for (let key in b){\n    if (b.hasOwnProperty(key)) { a[key] = b[key] }\n  }\n  return a;\n}\n\nexport function mobileCheck(){\n  if (typeof navigator !== 'undefined') {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 600\n  }\n  return null\n}\nexport const sample = items => items[Math.floor(Math.random()*items.length)]\n\nexport function rn(start,end) {\n  if (start == null) start = 0\n  if (end == null) end = 1\n  return start + (Math.random() * (end - start))\n}\n\nexport function ri(start,end) {\n  if (start == null) start = 0\n  if (end == null) end = 1\n  return Math.floor(start + (Math.random() * ((end - start) + 1)))\n}\n\nexport const q = sel => document.querySelector(sel)\n\nexport const color2Hex = (color) => {\n  if (typeof color == 'number'){\n    return '#' +  ('00000' + color.toString(16)).slice(-6)\n  } else return color\n}\n\nexport const color2Rgb = (color, alpha=1) => {\n  const hex = color2Hex(color)\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  const obj = result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n  } : null\n  return 'rgba('+ obj.r +','+ obj.g +','+ obj.b +','+ alpha +')'\n}\n\nexport const getBrightness = (threeColor) => {\n  return (0.299 * threeColor.r) + (0.587 * threeColor.g) + (0.114 * threeColor.b);\n}","import {extend, mobileCheck, q, color2Hex} from './helpers.js'\n// const DEBUGMODE = window.location.toString().indexOf('VANTADEBUG') !== -1\n\nconst win = typeof window == 'object'\nlet THREE = (win && window.THREE) || {}\nif (win && !window.VANTA) window.VANTA = {}\nconst VANTA = (win && window.VANTA) || {}\nVANTA.register = (name, Effect) => {\n  return VANTA[name] = (opts) => new Effect(opts)\n}\nVANTA.version = '0.5.21'\n\nexport {VANTA}\n\n// const ORBITCONTROLS = {\n//   enableZoom: false,\n//   userPanSpeed: 3,\n//   userRotateSpeed: 2.0,\n//   maxPolarAngle: Math.PI * 0.8, // (pi/2 is pure horizontal)\n//   mouseButtons: {\n//     ORBIT: THREE.MOUSE.LEFT,\n//     ZOOM: null,\n//     PAN: null\n//   }\n// }\n// if (DEBUGMODE) {\n//   extend(ORBITCONTROLS, {\n//     enableZoom: true,\n//     zoomSpeed: 4,\n//     minDistance: 100,\n//     maxDistance: 4500\n//   })\n// }\n\n// Namespace for errors\nconst error = function() {\n  Array.prototype.unshift.call(arguments, '[VANTA]')\n  return console.error.apply(this, arguments)\n}\n\nVANTA.VantaBase = class VantaBase {\n  constructor(userOptions = {}) {\n    if (!win) return false\n    VANTA.current = this\n    this.windowMouseMoveWrapper = this.windowMouseMoveWrapper.bind(this)\n    this.windowTouchWrapper = this.windowTouchWrapper.bind(this)\n    this.windowGyroWrapper = this.windowGyroWrapper.bind(this)\n    this.resize = this.resize.bind(this)\n    this.animationLoop = this.animationLoop.bind(this)\n    this.restart = this.restart.bind(this)\n\n    const defaultOptions = (typeof this.getDefaultOptions === 'function') ? this.getDefaultOptions() : this.defaultOptions\n    this.options = extend({\n      mouseControls: true,\n      touchControls: true,\n      gyroControls: false,\n      minHeight: 200,\n      minWidth: 200,\n      scale: 1,\n      scaleMobile: 1,\n    }, defaultOptions)\n\n    if (userOptions instanceof HTMLElement || typeof userOptions === 'string') {\n      userOptions = {el: userOptions}\n    }\n    extend(this.options, userOptions)\n\n    if (this.options.THREE) {\n      THREE = this.options.THREE // Optionally use a custom build of three.js\n    }\n\n    // Set element\n    this.el = this.options.el\n    if (this.el == null) {\n      error(\"Instance needs \\\"el\\\" param!\")\n    } else if (!(this.options.el instanceof HTMLElement)) {\n      const selector = this.el\n      this.el = q(selector)\n      if (!this.el) {\n        error(\"Cannot find element\", selector)\n        return\n      }\n    }\n\n    this.prepareEl()\n    this.initThree()\n    this.setSize() // Init needs size\n\n    try {\n      this.init()\n    } catch (e) {\n      // FALLBACK - just use color\n      error('Init error', e)\n      if (this.renderer && this.renderer.domElement) {\n        this.el.removeChild(this.renderer.domElement)\n      }\n      if (this.options.backgroundColor) {\n        console.log('[VANTA] Falling back to backgroundColor')\n        this.el.style.background = color2Hex(this.options.backgroundColor)\n      }\n      return\n    }\n\n    // After init\n    this.initMouse() // Triggers mouse, which needs to be called after init\n    this.resize()\n    this.animationLoop()\n\n    // Event listeners\n    const ad = window.addEventListener\n    ad('resize', this.resize)\n    window.requestAnimationFrame(this.resize) // Force a resize after the first frame\n\n    // Add event listeners on window, because this element may be below other elements, which would block the element's own mousemove event\n    if (this.options.mouseControls) {\n      ad('scroll', this.windowMouseMoveWrapper)\n      ad('mousemove', this.windowMouseMoveWrapper)\n    }\n    if (this.options.touchControls) {\n      ad('touchstart', this.windowTouchWrapper)\n      ad('touchmove', this.windowTouchWrapper)\n    }\n    if (this.options.gyroControls) {\n      ad('deviceorientation', this.windowGyroWrapper)\n    }\n  }\n\n  setOptions(userOptions={}){\n    extend(this.options, userOptions)\n    this.triggerMouseMove()\n  }\n\n  prepareEl() {\n    let i, child\n    // wrapInner for text nodes, so text nodes can be put into foreground\n    if (typeof Node !== 'undefined' && Node.TEXT_NODE) {\n      for (i = 0; i < this.el.childNodes.length; i++) {\n        const n = this.el.childNodes[i]\n        if (n.nodeType === Node.TEXT_NODE) {\n          const s = document.createElement('span')\n          s.textContent = n.textContent\n          n.parentElement.insertBefore(s, n)\n          n.remove()\n        }\n      }\n    }\n    // Set foreground elements\n    for (i = 0; i < this.el.children.length; i++) {\n      child = this.el.children[i]\n      if (getComputedStyle(child).position === 'static') {\n        child.style.position = 'relative'\n      }\n      if (getComputedStyle(child).zIndex === 'auto') {\n        child.style.zIndex = 1\n      }\n    }\n    // Set canvas and container style\n    if (getComputedStyle(this.el).position === 'static') {\n      this.el.style.position = 'relative'\n    }\n  }\n\n  applyCanvasStyles(canvasEl, opts={}){\n    extend(canvasEl.style, {\n      position: 'absolute',\n      zIndex: 0,\n      top: 0,\n      left: 0,\n      background: ''\n    })\n    extend(canvasEl.style, opts)\n    canvasEl.classList.add('vanta-canvas')\n  }\n\n  initThree() {\n    if (!THREE.WebGLRenderer) {\n      console.warn(\"[VANTA] No THREE defined on window\")\n      return\n    }\n    // Set renderer\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: true,\n      antialias: true\n    })\n    this.el.appendChild(this.renderer.domElement)\n    this.applyCanvasStyles(this.renderer.domElement)\n    if (isNaN(this.options.backgroundAlpha)) {\n      this.options.backgroundAlpha = 1\n    }\n\n    this.scene = new THREE.Scene()\n  }\n\n  getCanvasElement() {\n    if (this.renderer) {\n      return this.renderer.domElement // three.js\n    }\n    if (this.p5renderer) {\n      return this.p5renderer.canvas // p5\n    }\n  }\n\n  getCanvasRect() {\n    const canvas = this.getCanvasElement()\n    if (!canvas) return false\n    return canvas.getBoundingClientRect()\n  }\n\n  windowMouseMoveWrapper(e){\n    const rect = this.getCanvasRect()\n    if (!rect) return false\n    const x = e.clientX - rect.left\n    const y = e.clientY - rect.top\n    if (x>=0 && y>=0 && x<=rect.width && y<=rect.height) {\n      this.mouseX = x\n      this.mouseY = y\n      if (!this.options.mouseEase) this.triggerMouseMove(x, y)\n    }\n  }\n  windowTouchWrapper(e){\n    const rect = this.getCanvasRect()\n    if (!rect) return false\n    if (e.touches.length === 1) {\n      const x = e.touches[0].clientX - rect.left\n      const y = e.touches[0].clientY - rect.top\n      if (x>=0 && y>=0 && x<=rect.width && y<=rect.height) {\n        this.mouseX = x\n        this.mouseY = y\n        if (!this.options.mouseEase) this.triggerMouseMove(x, y)\n      }\n    }\n  }\n  windowGyroWrapper(e){\n    const rect = this.getCanvasRect()\n    if (!rect) return false\n    const x = Math.round(e.alpha * 2) - rect.left\n    const y = Math.round(e.beta * 2) - rect.top\n    if (x>=0 && y>=0 && x<=rect.width && y<=rect.height) {\n      this.mouseX = x\n      this.mouseY = y\n      if (!this.options.mouseEase) this.triggerMouseMove(x, y)\n    }\n  }\n\n  triggerMouseMove(x, y) {\n    if (x === undefined && y === undefined) { // trigger at current position\n      if (this.options.mouseEase) {\n        x = this.mouseEaseX\n        y = this.mouseEaseY\n      } else {\n        x = this.mouseX\n        y = this.mouseY\n      }\n    }\n    if (this.uniforms) {\n      this.uniforms.iMouse.value.x = x / this.scale // pixel values\n      this.uniforms.iMouse.value.y = y / this.scale // pixel values\n    }\n    const xNorm = x / this.width // 0 to 1\n    const yNorm = y / this.height // 0 to 1\n    typeof this.onMouseMove === \"function\" ? this.onMouseMove(xNorm, yNorm) : void 0\n  }\n\n  setSize() {\n    this.scale || (this.scale = 1)\n    if (mobileCheck() && this.options.scaleMobile) {\n      this.scale = this.options.scaleMobile\n    } else if (this.options.scale) {\n      this.scale = this.options.scale\n    }\n    this.width = Math.max(this.el.offsetWidth, this.options.minWidth)\n    this.height = Math.max(this.el.offsetHeight, this.options.minHeight)\n  }\n  initMouse() {\n    // Init mouseX and mouseY\n    if ((!this.mouseX && !this.mouseY) ||\n      (this.mouseX === this.options.minWidth/2 && this.mouseY === this.options.minHeight/2)) {\n      this.mouseX = this.width/2\n      this.mouseY = this.height/2\n      this.triggerMouseMove(this.mouseX, this.mouseY)\n    }\n  }\n\n  resize() {\n    this.setSize()\n    if (this.camera) {\n      this.camera.aspect = this.width / this.height\n      if (typeof this.camera.updateProjectionMatrix === \"function\") {\n        this.camera.updateProjectionMatrix()\n      }\n    }\n    if (this.renderer) {\n      this.renderer.setSize(this.width, this.height)\n      this.renderer.setPixelRatio(window.devicePixelRatio / this.scale)\n    }\n    typeof this.onResize === \"function\" ? this.onResize() : void 0\n  }\n\n  isOnScreen() {\n    const elHeight = this.el.offsetHeight\n    const elRect = this.el.getBoundingClientRect()\n    const scrollTop = (window.pageYOffset ||\n      (document.documentElement || document.body.parentNode || document.body).scrollTop\n    )\n    const offsetTop = elRect.top + scrollTop\n    const minScrollTop = offsetTop - window.innerHeight\n    const maxScrollTop = offsetTop + elHeight\n    return minScrollTop <= scrollTop && scrollTop <= maxScrollTop\n  }\n\n  animationLoop() {\n    // Step time\n    this.t || (this.t = 0)\n    this.t += 1\n    // Uniform time\n    this.t2 || (this.t2 = 0)\n    this.t2 += (this.options.speed || 1)\n    if (this.uniforms) {\n      this.uniforms.iTime.value = this.t2 * 0.016667 // iTime is in seconds\n    }\n\n    if (this.options.mouseEase) {\n      this.mouseEaseX = this.mouseEaseX || this.mouseX || 0\n      this.mouseEaseY = this.mouseEaseY || this.mouseY || 0\n      if (Math.abs(this.mouseEaseX-this.mouseX) + Math.abs(this.mouseEaseY-this.mouseY) > 0.1) {\n        this.mouseEaseX += (this.mouseX - this.mouseEaseX) * 0.05\n        this.mouseEaseY += (this.mouseY - this.mouseEaseY) * 0.05\n        this.triggerMouseMove(this.mouseEaseX, this.mouseEaseY)\n      }\n    }\n\n    // Only animate if element is within view\n    if (this.isOnScreen() || this.options.forceAnimate) {\n      if (typeof this.onUpdate === \"function\") {\n        this.onUpdate()\n      }\n      if (this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera)\n        this.renderer.setClearColor(this.options.backgroundColor, this.options.backgroundAlpha)\n      }\n      // if (this.stats) this.stats.update()\n      // if (this.renderStats) this.renderStats.update(this.renderer)\n      if (this.fps && this.fps.update) this.fps.update()\n      if (typeof this.afterRender === \"function\") this.afterRender()\n    }\n    return this.req = window.requestAnimationFrame(this.animationLoop)\n  }\n\n  // setupControls() {\n  //   if (DEBUGMODE && THREE.OrbitControls) {\n  //     this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement)\n  //     extend(this.controls, ORBITCONTROLS)\n  //     return this.scene.add(new THREE.AxisHelper(100))\n  //   }\n  // }\n\n  restart() {\n    // Restart the effect without destroying the renderer\n    if (this.scene) {\n      while (this.scene.children.length) {\n        this.scene.remove(this.scene.children[0])\n      }\n    }\n    if (typeof this.onRestart === \"function\") {\n      this.onRestart()\n    }\n    this.init()\n  }\n\n  init() {\n    if (typeof this.onInit === \"function\") {\n      this.onInit()\n    }\n    // this.setupControls()\n  }\n\n  destroy() {\n    if (typeof this.onDestroy === \"function\") {\n      this.onDestroy()\n    }\n    const rm = window.removeEventListener\n    rm('touchstart', this.windowTouchWrapper)\n    rm('touchmove', this.windowTouchWrapper)\n    rm('scroll', this.windowMouseMoveWrapper)\n    rm('mousemove', this.windowMouseMoveWrapper)\n    rm('deviceorientation', this.windowGyroWrapper)\n    rm('resize', this.resize)\n\n    window.cancelAnimationFrame(this.req)\n    if (this.renderer) {\n      if (this.renderer.domElement) {\n        this.el.removeChild(this.renderer.domElement)\n      }\n      this.renderer = null\n      this.scene = null\n    }\n\n    if (VANTA.current === this) {\n      VANTA.current = null\n    }\n  }\n}\n\nexport default VANTA.VantaBase"],"sourceRoot":"webpack:///"}